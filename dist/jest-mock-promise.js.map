{"version":3,"file":"jest-mock-promise.js","mappings":";CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAQ,qBAAuBD,IAE/BD,EAAK,qBAAuBC,IAR9B,CASGK,MAAM,WACT,4CCPA,IAAIC,EAFJC,OAAOC,eAAeP,EAAS,aAAc,CAAEQ,OAAO,IACtDR,EAAQK,kBAAe,EAEvB,SAAWA,GACPA,EAAaA,EAAsB,QAAI,GAAK,UAC5CA,EAAaA,EAAuB,SAAI,GAAK,WAC7CA,EAAaA,EAAuB,SAAI,GAAK,WAHjD,CAIGA,IAAiBA,EAAe,KACnCL,EAAQK,aAAeA,ICRnBI,EAA2B,GAG/B,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAaZ,QAGrB,IAAIC,EAASQ,EAAyBE,GAAY,CAGjDX,QAAS,IAOV,OAHAc,EAAoBH,GAAUV,EAAQA,EAAOD,QAASU,GAG/CT,EAAOD,qCCDfM,OAAOC,eAAeP,EAAS,aAAc,CAAEQ,OAAO,IACtD,IAAIO,EAA4B,EAAQ,KACpCC,EAAiC,WACjC,SAASA,EAAgBC,GACrBC,KAAKC,SAAW,GAChBD,KAAKE,UAAY,EACjBF,KAAKG,MAAQN,EAA0BV,aAAaiB,QAEhDL,GACAA,EAAWC,KAAKK,UAAUC,KAAKN,MAAOA,KAAKO,SAASD,KAAKN,OAwNjE,OAjNAF,EAAgBU,UAAUH,UAAY,SAAUf,GAC5CU,KAAKS,KAAOnB,EACZ,IAAIoB,EAAYpB,EAChBU,KAAKG,MAAQN,EAA0BV,aAAawB,SACpDX,KAAKY,SAAM,EACX,IAAK,IAAIC,EAAQb,KAAKC,SAASa,OAAQd,KAAKE,UAAYW,EAAOb,KAAKE,YAAa,CAC7E,IAAIa,EAAKf,KAAKC,SAASD,KAAKE,WAE5B,GAAIa,EAAGC,OAASD,EAAGE,QAEf,YADAjB,KAAKkB,cAGT,IAEIR,EAAYK,EAAGI,KAAKT,GAExB,MAAOU,GAGHpB,KAAKE,YACLF,KAAKO,SAASa,MAS1BtB,EAAgBU,UAAUD,SAAW,SAAUK,GAC3CZ,KAAKG,MAAQN,EAA0BV,aAAakC,SACpDrB,KAAKY,IAAMA,EAEX,IAAK,IAAIC,EAAQb,KAAKC,SAASa,OAAQd,KAAKE,UAAYW,EAAOb,KAAKE,YAAa,CAC7E,IAAwCoB,EAApCP,EAAKf,KAAKC,SAASD,KAAKE,WAC5B,GAAIa,EAAGC,MACH,IACIM,EAAgBP,EAAGC,MAAMJ,GAEzBZ,KAAKE,YACLF,KAAKK,UAAUiB,GAEf,MAEJ,MAAOF,GAGHpB,KAAKE,YACLF,KAAKO,SAASa,GACd,WAGCL,EAAGE,SACRjB,KAAKkB,gBAQjBpB,EAAgBU,UAAUU,YAAc,WAIpC,IAFA,IAAIK,GAAe,EAEVV,EAAQb,KAAKC,SAASa,OAAQd,KAAKE,UAAYW,EAAOb,KAAKE,YAAa,CAC7E,IAAIa,EAAKf,KAAKC,SAASD,KAAKE,WAC5B,IACI,GAAIa,EAAGE,QAEHF,EAAGE,UACHM,GAAe,MAEd,IAAIR,EAAGI,MAAQI,EAAc,CAE9BvB,KAAKK,YACL,MAEC,GAAIU,EAAGC,MAAO,CACfO,GAAe,EACf,WAGR,MAAOH,GAGHpB,KAAKE,YACLF,KAAKO,SAASa,GACd,SAaZtB,EAAgBU,UAAUW,KAAO,SAAUK,EAAaC,GAWpD,OAV2B,mBAAhBD,IAMPA,EAAc,SAAUE,GAAK,OAAOA,IAIhC1B,KAAKG,OACT,KAAKN,EAA0BV,aAAakC,SACpCI,GACAA,EAAWzB,KAAKY,KAEpB,MACJ,KAAKf,EAA0BV,aAAawB,SAKpC,IAAIgB,EAAa,IAAI7B,EAErB,OADA6B,EAAWC,QAAQJ,EAAYxB,KAAKS,OAC7B,EAEf,QACIT,KAAKC,SAAS4B,KAAK,CAAEV,KAAMK,IACvBC,GACAzB,KAAKC,SAAS4B,KAAK,CAAEb,MAAOS,IAGxC,OAAO,MAUX3B,EAAgBU,UAAUQ,MAAQ,SAAUS,GASxC,OANIzB,KAAKG,QAAUN,EAA0BV,aAAakC,SACtDI,EAAWzB,KAAKY,KAGhBZ,KAAKC,SAAS4B,KAAK,CAAEb,MAAOS,IAEzB,MAMX3B,EAAgBU,UAAUS,QAAU,SAAUa,GAS1C,OANI9B,KAAKG,QAAUN,EAA0BV,aAAaiB,QACtD0B,IAGA9B,KAAKC,SAAS4B,KAAK,CAAEZ,QAASa,IAE3B,MASXhC,EAAgBU,UAAUoB,QAAU,SAAUnB,GAC1CT,KAAKK,UAAUI,IASnBX,EAAgBU,UAAUuB,OAAS,SAAUnB,GACzCZ,KAAKO,SAASK,IAMlBd,EAAgB8B,QAAU,SAAUnB,GAEhC,OADAuB,QAAQC,KAAK,mJACN,IAAKnC,GAAgB,SAAU8B,EAASG,GAC3CG,WAAWN,EAAQnB,GAAO,OAOlCX,EAAgBiC,OAAS,SAAUnB,GAE/B,OADAoB,QAAQC,KAAK,iJACN,IAAKnC,GAAgB,SAAU8B,EAASG,GAC3CG,WAAWH,EAAOnB,GAAM,OAGzBd,EA/NyB,GAiOpChB,EAAA,QAAkBgB","sources":["webpack://jest-mock-promise/webpack/universalModuleDefinition","webpack://jest-mock-promise/./lib/jest-mock-promise-types.ts","webpack://jest-mock-promise/webpack/bootstrap","webpack://jest-mock-promise/./lib/jest-mock-promise.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"jest-mock-promise\"] = factory();\n\telse\n\t\troot[\"jest-mock-promise\"] = factory();\n})(self, function() {\nreturn ","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PromiseState = void 0;\nvar PromiseState;\n(function (PromiseState) {\n    PromiseState[PromiseState[\"pending\"] = 0] = \"pending\";\n    PromiseState[PromiseState[\"resolved\"] = 1] = \"resolved\";\n    PromiseState[PromiseState[\"rejected\"] = 2] = \"rejected\";\n})(PromiseState || (PromiseState = {}));\nexports.PromiseState = PromiseState;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\n/**\n * Synchronous Promise, which gets settled (resolved or settled) in a synchronous manner.\n *\n * `JestMockPromise` was written to simplify unit testing mocking (i.e. in [Jest](https://facebook.github.io/jest/) )\n *\n * In order to simplify synchronious promise settling two additional methods\n * were added to the promise instance:\n *   - `resolve` = forces the given promise to be resolved right away\n *   - `reject` = forces the given promise to be rejected right away\n *\n * By using these methods, we can write something like (provided that the Promise is mocked):\n *\n *    let promise = ExternalComponent.doAsyncWork();\n *    promise.resolve({ label: 'this is some mock data' });\n *\n * @author   knee-cola<nikola.derezic@gmail.com>\n * @license  @license MIT License, http://www.opensource.org/licenses/MIT\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar jest_mock_promise_types_1 = require(\"./jest-mock-promise-types\");\nvar JestMockPromise = /** @class */ (function () {\n    function JestMockPromise(callbackFn) {\n        this.handlers = [];\n        this.handlerIx = 0;\n        this.state = jest_mock_promise_types_1.PromiseState.pending;\n        // if given, calling the given function\n        if (callbackFn) {\n            callbackFn(this.resolveFn.bind(this), this.rejectFn.bind(this));\n        }\n    }\n    /**\n     * Resolves the given promise\n     * @param value data which should be passed to `then` handler functions\n     */\n    JestMockPromise.prototype.resolveFn = function (value) {\n        this.data = value;\n        var nextValue = value;\n        this.state = jest_mock_promise_types_1.PromiseState.resolved;\n        this.err = void 0;\n        for (var maxIx = this.handlers.length; this.handlerIx < maxIx; this.handlerIx++) {\n            var el = this.handlers[this.handlerIx];\n            // stop the execution at first `catch` handler you run into\n            if (el.catch || el.finally) {\n                this.callFinally();\n                return;\n            }\n            try {\n                // calling a `then` handler with the value returned by the previous handler\n                nextValue = el.then(nextValue);\n            }\n            catch (ex) {\n                // in case `then` or a `finally` handler throws an error\n                // > pass it down to a first `catch` handler\n                this.handlerIx++;\n                this.rejectFn(ex);\n            }\n        }\n        ;\n    };\n    /**\n     * Rejects the given promise\n     * @param err error object which is to be passed as a param to `catch` function\n     */\n    JestMockPromise.prototype.rejectFn = function (err) {\n        this.state = jest_mock_promise_types_1.PromiseState.rejected;\n        this.err = err;\n        // find the first `catch` handler and call it\n        for (var maxIx = this.handlers.length; this.handlerIx < maxIx; this.handlerIx++) {\n            var el = this.handlers[this.handlerIx], returnedValue;\n            if (el.catch) {\n                try {\n                    returnedValue = el.catch(err);\n                    // try executing `then`/`finally` handlers which follow\n                    this.handlerIx++;\n                    this.resolveFn(returnedValue);\n                    // stop the execution as soon as you run into a first catch element\n                    break;\n                }\n                catch (ex) {\n                    // in an error was thrown within `catch` block\n                    // > pass it down to closest `catch` handler\n                    this.handlerIx++;\n                    this.rejectFn(ex);\n                    break; // the execution will continue from `rejectFn`\n                }\n            }\n            else if (el.finally) {\n                this.callFinally();\n            }\n        }\n        ;\n    };\n    /**\n     * Calls `finally` handlers\n     */\n    JestMockPromise.prototype.callFinally = function () {\n        /** is set to `true` after a successful `finally` call */\n        var callNextThen = false;\n        // find the first `finally` and call it\n        for (var maxIx = this.handlers.length; this.handlerIx < maxIx; this.handlerIx++) {\n            var el = this.handlers[this.handlerIx];\n            try {\n                if (el.finally) {\n                    // calling a `finally` handler\n                    el.finally(); // finally doesn't receive any data\n                    callNextThen = true; // if `then` is next - call it\n                }\n                else if (el.then && callNextThen) {\n                    // if you run into `then` right after finally > let the dedicated handler process it\n                    this.resolveFn();\n                    break; // the execution will continue from `resolveFn`\n                }\n                else if (el.catch) {\n                    callNextThen = false;\n                    continue; // skipping `catch` and search for the next `finally`\n                }\n            }\n            catch (ex) {\n                // in case `then` or a `finally` handler throws an error\n                // > pass it down to a first `catch` handler\n                this.handlerIx++;\n                this.rejectFn(ex);\n                break; // the execution will continue from `rejectFn`\n            }\n        }\n    };\n    /**\n     * Appends fulfillment and rejection handlers to the promise,\n     * and returns a new promise resolving to the return value of\n     * the called handler, or to its original settled value if the\n     * promise was not handled (i.e. if the relevant handler\n     * onFulfilled or onRejected is not a function).\n     * @param onFulfilled fulfillment handler function\n     * @param onRejected rejection handler function\n     */\n    JestMockPromise.prototype.then = function (onFulfilled, onRejected) {\n        if (typeof onFulfilled !== 'function') {\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then\n            // \"onFulfilled: A Function called if the Promise is fulfilled.\n            // This function has one argument, the fulfillment value.\n            // If it is not a function, it is internally replaced with an\n            // \"Identity\" function (it returns the received argument)\"\n            onFulfilled = function (x) { return x; };\n        }\n        // if the promise is already settled (resolved or rejected)\n        // > call the apropriate handler\n        switch (this.state) {\n            case jest_mock_promise_types_1.PromiseState.rejected:\n                if (onRejected) {\n                    onRejected(this.err);\n                }\n                break;\n            case jest_mock_promise_types_1.PromiseState.resolved:\n                {\n                    // in order to allow chaining we need to return\n                    // a new Promise resolved with the value returned\n                    // by `onFulfilled`\n                    var newPromise = new JestMockPromise();\n                    newPromise.resolve(onFulfilled(this.data));\n                    return (newPromise);\n                }\n            default:\n                this.handlers.push({ then: onFulfilled });\n                if (onRejected) {\n                    this.handlers.push({ catch: onRejected });\n                }\n        }\n        return (this);\n    };\n    /**\n     * Appends a rejection handler callback to the promise,\n     * and returns a new promise resolving to the return\n     * value of the callback if it is called, or to its\n     * original fulfillment value if the promise is instead\n     * fulfilled.\n     * @param onRejected rejection handler function\n     */\n    JestMockPromise.prototype.catch = function (onRejected) {\n        // if the promise is already rejected\n        // > call the handler right away\n        if (this.state === jest_mock_promise_types_1.PromiseState.rejected) {\n            onRejected(this.err);\n        }\n        else {\n            this.handlers.push({ catch: onRejected });\n        }\n        return (this);\n    };\n    /**\n     * Appends a finally handler callback to the promise\n     * @param onFinally finally handler function\n     */\n    JestMockPromise.prototype.finally = function (onFinally) {\n        // if the promise is already resolved or rejected\n        // > call the handler right away\n        if (this.state !== jest_mock_promise_types_1.PromiseState.pending) {\n            onFinally();\n        }\n        else {\n            this.handlers.push({ finally: onFinally });\n        }\n        return (this);\n    };\n    /**\n     * Resolves the promise with the given promise data.\n     * This is a non-standard method, which should be the last\n     * one to be called, after all the fulfillment and rejection\n     * handlers have been registered.\n     * @param {*} data\n     */\n    JestMockPromise.prototype.resolve = function (data) {\n        this.resolveFn(data);\n    };\n    /**\n     * Rejects the promise with the given promise with the given error object.\n     * This is a non-standard method, which should be the last\n     * one to be called, after all the fulfillment and rejection\n     * handlers have been registered.\n     * @param {*} data\n     */\n    JestMockPromise.prototype.reject = function (err) {\n        this.rejectFn(err);\n    };\n    /**\n     * Creates a resolved promise with the given data\n     * @param data data which should be passed to `then` handler functions\n     */\n    JestMockPromise.resolve = function (data) {\n        console.warn('a promise created via `JestMockPromise.resolve` will be executed async ... for sync execution call `resolve` method on an instance of `Promise`');\n        return (new JestMockPromise(function (resolve, reject) {\n            setTimeout(resolve(data), 0);\n        }));\n    };\n    /**\n     * Creates a rejected promise with the given data\n     * @param err error object which is to be passed as a param to `catch` function\n     */\n    JestMockPromise.reject = function (err) {\n        console.warn('a promise created via `JestMockPromise.reject` will be executed async ... for sync execution call `reject` method on an instance of `Promise`');\n        return (new JestMockPromise(function (resolve, reject) {\n            setTimeout(reject(err), 0);\n        }));\n    };\n    return JestMockPromise;\n}());\nexports.default = JestMockPromise;\n"],"names":["root","factory","exports","module","define","amd","self","PromiseState","Object","defineProperty","value","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","jest_mock_promise_types_1","JestMockPromise","callbackFn","this","handlers","handlerIx","state","pending","resolveFn","bind","rejectFn","prototype","data","nextValue","resolved","err","maxIx","length","el","catch","finally","callFinally","then","ex","rejected","returnedValue","callNextThen","onFulfilled","onRejected","x","newPromise","resolve","push","onFinally","reject","console","warn","setTimeout"],"sourceRoot":""}