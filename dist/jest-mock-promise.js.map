{"version":3,"file":"jest-mock-promise.js","mappings":"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","sources":["webpack://jest-mock-promise/webpack/universalModuleDefinition","webpack://jest-mock-promise/./lib/jest-mock-promise-types.ts","webpack://jest-mock-promise/webpack/bootstrap","webpack://jest-mock-promise/./lib/jest-mock-promise.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"jest-mock-promise\"] = factory();\n\telse\n\t\troot[\"jest-mock-promise\"] = factory();\n})(this, function() {\nreturn ","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PromiseState = void 0;\nvar PromiseState;\n(function (PromiseState) {\n    PromiseState[PromiseState[\"pending\"] = 0] = \"pending\";\n    PromiseState[PromiseState[\"resolved\"] = 1] = \"resolved\";\n    PromiseState[PromiseState[\"rejected\"] = 2] = \"rejected\";\n})(PromiseState || (PromiseState = {}));\nexports.PromiseState = PromiseState;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\n/**\n * Synchronous Promise, which gets settled (resolved or settled) in a synchronous manner.\n *\n * `JestMockPromise` was written to simplify unit testing mocking (i.e. in [Jest](https://facebook.github.io/jest/) )\n *\n * In order to simplify synchronious promise settling two additional methods\n * were added to the promise instance:\n *   - `resolve` = forces the given promise to be resolved right away\n *   - `reject` = forces the given promise to be rejected right away\n *\n * By using these methods, we can write something like (provided that the Promise is mocked):\n *\n *    let promise = ExternalComponent.doAsyncWork();\n *    promise.resolve({ label: 'this is some mock data' });\n *\n * @author   knee-cola<nikola.derezic@gmail.com>\n * @license  @license MIT License, http://www.opensource.org/licenses/MIT\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar jest_mock_promise_types_1 = require(\"./jest-mock-promise-types\");\nvar JestMockPromise = /** @class */ (function () {\n    function JestMockPromise(callbackFn) {\n        this.queue = [];\n        this.state = jest_mock_promise_types_1.PromiseState.pending;\n        // if given, calling the given function\n        if (callbackFn) {\n            callbackFn(this.resolve.bind(this), this.reject.bind(this));\n        }\n    }\n    Object.defineProperty(JestMockPromise.prototype, Symbol.toStringTag, {\n        get: function () {\n            return \"JestMockPromise\";\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Resolves promises at a given level\n     * @param currLevel list of promises which need to be resolved at this level\n     */\n    JestMockPromise.processLevel = function (currLevel) {\n        if (currLevel.length === 0)\n            return;\n        var nextLevel = [];\n        currLevel.forEach(function (_a) {\n            var instance = _a.instance, value = _a.value, err = _a.err, newState = _a.newState;\n            var queue = instance.queue;\n            instance.state = newState;\n            instance.value = value;\n            instance.err = err;\n            queue.forEach(function (_a, ix) {\n                var nextPromise = _a.nextPromise, onFulfilled = _a.onFulfilled, onRejected = _a.onRejected, onFinally = _a.onFinally;\n                // by default pass the original value and state to the next level\n                var nextLevelItem = {\n                    instance: nextPromise,\n                    value: value,\n                    err: err,\n                    newState: newState\n                };\n                switch (newState) {\n                    case jest_mock_promise_types_1.PromiseState.resolved:\n                        if (onFulfilled) {\n                            try {\n                                nextLevelItem.value = onFulfilled(value); // call the handler\n                            }\n                            catch (err) {\n                                // reject the next promise\n                                nextLevelItem = {\n                                    instance: nextPromise,\n                                    err: err,\n                                    newState: jest_mock_promise_types_1.PromiseState.rejected\n                                };\n                            }\n                        }\n                        break;\n                    case jest_mock_promise_types_1.PromiseState.rejected:\n                        if (onRejected) {\n                            try {\n                                // reject returns no value\n                                onRejected(err);\n                                // after the error is caught - the promise is RESOLVED\n                                nextLevelItem.newState = jest_mock_promise_types_1.PromiseState.resolved;\n                            }\n                            catch (err) {\n                                // attach new error the the next level\n                                // - we do not need to change the state -> it remains rejected\n                                nextLevelItem.err = err;\n                            }\n                        }\n                        else {\n                            // IF the catch is handled\n                            // > throw the error!\n                            setTimeout(function () {\n                                console.error(\"Uncaught (in promise) Error: \".concat(err));\n                                // not throwing an exception in order not to brake unit tests\n                                // throw new Error(`Uncaught (in promise) Error: ${err}`)\n                            });\n                        }\n                        break;\n                }\n                // IF handler is registered\n                if (onFinally) {\n                    try {\n                        // finally accepts no params and returns nothing\n                        onFinally();\n                    }\n                    catch (err) {\n                        // reject the next promise\n                        nextLevelItem = {\n                            instance: nextPromise,\n                            err: err,\n                            newState: jest_mock_promise_types_1.PromiseState.rejected\n                        };\n                    }\n                }\n                nextLevel.push(nextLevelItem);\n            });\n        });\n        // resolve the next level promises (recursive call)\n        JestMockPromise.processLevel(nextLevel);\n    };\n    /**\n     * Appends fulfillment and rejection handlers to the promise,\n     * and returns a new promise resolving to the return value of\n     * the called handler, or to its original settled value if the\n     * promise was not handled (i.e. if the relevant handler\n     * onFulfilled or onRejected is not a function).\n     * @param onFulfilled fulfillment handler function\n     * @param onRejected rejection handler function\n     */\n    JestMockPromise.prototype.then = function (onFulfilled, onRejected) {\n        if (typeof onFulfilled !== 'function') {\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then\n            // \"onFulfilled: A Function called if the Promise is fulfilled.\n            // This function has one argument, the fulfillment value.\n            // If it is not a function, it is internally replaced with an\n            // \"Identity\" function (it returns the received argument)\"\n            onFulfilled = function (x) { return x; };\n        }\n        var nextPromise = new JestMockPromise();\n        // if the promise is already settled (resolved or rejected)\n        // > call the apropriate handler\n        switch (this.state) {\n            case jest_mock_promise_types_1.PromiseState.rejected:\n                if (onRejected) {\n                    try {\n                        onRejected(this.err);\n                        nextPromise.resolve(); // since the rejection is caught, the next promise is resolved\n                    }\n                    catch (ex) {\n                        nextPromise.reject(ex);\n                    }\n                }\n                else {\n                    // if the rejection is not caught\n                    // > reject the next promise\n                    nextPromise.reject(this.err);\n                }\n                break;\n            case jest_mock_promise_types_1.PromiseState.resolved:\n                try {\n                    nextPromise.resolve(onFulfilled(this.value));\n                }\n                catch (ex) {\n                    nextPromise.reject(ex);\n                }\n                break;\n            default:\n                break;\n        }\n        this.queue.push({\n            onFulfilled: onFulfilled,\n            onRejected: onRejected,\n            nextPromise: nextPromise\n        });\n        // in order to allow chaining we need to return the new Promise\n        return (nextPromise);\n    };\n    /**\n     * Appends a rejection handler callback to the promise,\n     * and returns a new promise resolving to the return\n     * value of the callback if it is called, or to its\n     * original fulfillment value if the promise is instead\n     * fulfilled.\n     * @param onRejected rejection handler function\n     */\n    JestMockPromise.prototype.catch = function (onRejected) {\n        var nextPromise = new JestMockPromise();\n        // if the promise is already rejected\n        // > call the handler right away\n        if (this.state === jest_mock_promise_types_1.PromiseState.rejected) {\n            try {\n                onRejected(this.err);\n                nextPromise.resolve(); // after a the error is caught the next promise is resolved\n            }\n            catch (ex) {\n                nextPromise.reject(ex);\n            }\n        }\n        this.queue.push({\n            onRejected: onRejected,\n            nextPromise: nextPromise\n        });\n        return (nextPromise);\n    };\n    /**\n     * Appends a finally handler callback to the promise\n     * @param onFinally finally handler function\n     */\n    JestMockPromise.prototype.finally = function (onFinally) {\n        var nextPromise = new JestMockPromise();\n        // if the promise is already resolved or rejected\n        // > call the handler right away\n        if (this.state !== jest_mock_promise_types_1.PromiseState.pending) {\n            try {\n                onFinally();\n                nextPromise.resolve(this.value);\n            }\n            catch (ex) {\n                nextPromise.reject(ex);\n            }\n        }\n        this.queue.push({\n            onFinally: onFinally,\n            nextPromise: nextPromise\n        });\n        return (nextPromise);\n    };\n    /**\n     * Resolves the promise with the given promise data.\n     * This is a non-standard method, which should be the last\n     * one to be called, after all the fulfillment and rejection\n     * handlers have been registered.\n     * @param {*} value\n     */\n    JestMockPromise.prototype.resolve = function (value) {\n        JestMockPromise.processLevel([{ instance: this, value: value, newState: jest_mock_promise_types_1.PromiseState.resolved }]);\n    };\n    /**\n     * Rejects the promise with the given promise with the given error object.\n     * This is a non-standard method, which should be the last\n     * one to be called, after all the fulfillment and rejection\n     * handlers have been registered.\n     * @param {*} data\n     */\n    JestMockPromise.prototype.reject = function (err) {\n        JestMockPromise.processLevel([{ instance: this, err: err, newState: jest_mock_promise_types_1.PromiseState.rejected }]);\n    };\n    /**\n     * Creates a resolved promise with the given data\n     * @param data data which should be passed to `then` handler functions\n     */\n    JestMockPromise.resolve = function (data) {\n        return (new JestMockPromise(function (resolve, reject) {\n            setTimeout(function () { return resolve(data); }, 100);\n        }));\n    };\n    /**\n     * Creates a rejected promise with the given data\n     * @param err error object which is to be passed as a param to `catch` function\n     */\n    JestMockPromise.reject = function (err) {\n        return (new JestMockPromise(function (resolve, reject) {\n            setTimeout(function () { return reject(err); }, 0);\n        }));\n    };\n    return JestMockPromise;\n}());\nexports.default = JestMockPromise;\n"],"names":["root","factory","exports","module","define","amd","this","PromiseState","Object","defineProperty","value","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","jest_mock_promise_types_1","JestMockPromise","callbackFn","queue","state","pending","resolve","bind","reject","prototype","Symbol","toStringTag","get","enumerable","configurable","processLevel","currLevel","length","nextLevel","forEach","_a","instance","err","newState","ix","nextPromise","onFulfilled","onRejected","onFinally","nextLevelItem","resolved","rejected","setTimeout","console","error","concat","push","then","x","ex","catch","finally","data"],"sourceRoot":""}